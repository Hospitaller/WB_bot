import logging
from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes
import aiohttp
import json
from datetime import datetime, time, timedelta
import os
import asyncio
import pytz
import signal
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ö–æ–Ω—Ñ–∏–≥
CONFIG = {
    'AUTH_TOKEN': os.getenv('AUTH_TOKEN'),
    'TG_API_KEY': os.getenv('TG_API_KEY'),
    'API_URLS': {
        'first': "https://seller-analytics-api.wildberries.ru/api/v1/warehouse_remains?groupBySa=true",
        'second': "https://seller-analytics-api.wildberries.ru/api/v1/warehouse_remains/tasks/{task_id}/download"
    },
    'LOW_STOCK_THRESHOLD': 20,
    'WORKING_HOURS': "08-22",  # –ß–∞—Å—ã —Ä–∞–±–æ—Ç—ã (–ú–°–ö)
    'CHECK_INTERVAL': 240,  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ –º–∏–Ω—É—Ç–∞—Ö
    'DELAY_BETWEEN_REQUESTS': 30,
    'LOG_FILE': 'wb_bot_critical.log'
}

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
if not CONFIG['AUTH_TOKEN'] or not CONFIG['TG_API_KEY']:
    raise ValueError("–ù–µ –Ω–∞–π–¥–µ–Ω—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è AUTH_TOKEN –∏/–∏–ª–∏ TG_API_KEY")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –≤ —Ñ–∞–π–ª
logging.basicConfig(
    level=logging.CRITICAL,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(CONFIG['LOG_FILE']),
    ]
)

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –∫–æ–Ω—Å–æ–ª—å
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)
logger = logging.getLogger(__name__)
logger.addHandler(console_handler)

# –ö–ª–∞—Å—Å –±–æ—Ç–∞
class WBStockBot:
    def __init__(self, application):
        self.working_hours_start, self.working_hours_end = map(int, CONFIG['WORKING_HOURS'].split('-'))
        self.timezone = pytz.timezone('Europe/Moscow')
        self.application = application
        self.active_jobs = {}

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è
    def is_working_time(self):
        now = datetime.now(self.timezone)
        current_hour = now.hour
        return self.working_hours_start <= current_hour < self.working_hours_end

    # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ —Å–∫–ª–∞–¥–µ
    def format_stock_data(self, data, highlight_low=False):
        if not isinstance(data, list):
            return None
        result = []
        low_stock_items = []
        
        for item in data:
            vendor_code = item.get('vendorCode', 'N/A')
            warehouses = item.get('warehouses', [])
            
            total_warehouse = next(
                (wh for wh in warehouses if wh.get('warehouseName') == "–í—Å–µ–≥–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ —Å–∫–ª–∞–¥–∞—Ö"),
                None
            )
            
            if not total_warehouse:
                continue
                
            quantity = total_warehouse.get('quantity', 0)
            
            item_text = (
                f"–ê—Ä—Ç–∏–∫—É–ª: {vendor_code}\n"
                f"–û—Å—Ç–∞—Ç–æ–∫: {quantity}\n"
                f"{'-'*30}"
            )
            
            result.append(item_text)
            
            if quantity <= CONFIG['LOW_STOCK_THRESHOLD']:
                low_stock_items.append(item_text)
        
        if highlight_low:
            return low_stock_items
        return result

    async def fetch_wb_data(self, context: ContextTypes.DEFAULT_TYPE):
        """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö"""
        chat_id = context.job.chat_id if hasattr(context, 'job') else context._chat_id
        
        if not self.is_working_time():
            logger.info(f"–°–µ–π—á–∞—Å –Ω–µ—Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è –¥–ª—è —á–∞—Ç–∞ {chat_id}")
            return
            
        try:
            headers = {
                'Accept': 'application/json',
                'Authorization': CONFIG['AUTH_TOKEN']
            }
            
            timeout = aiohttp.ClientTimeout(total=60)  # –û–±—â–∏–π —Ç–∞–π–º–∞—É—Ç 60 —Å–µ–∫—É–Ω–¥
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # –ü–µ—Ä–≤—ã–π –∑–∞–ø—Ä–æ—Å
                await context.bot.send_message(chat_id=chat_id, text="üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å—Ç–∞—Ç–∫–æ–≤...")
                first_response = await self.make_api_request(session, CONFIG['API_URLS']['first'], headers, context, chat_id)
                
                if not first_response:
                    return
                
                task_id = first_response.get('data', {}).get('taskId')
                if not task_id:
                    await context.bot.send_message(chat_id=chat_id, text="‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å task ID")
                    return
                
                # –û–∂–∏–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ –≤—Ç–æ—Ä—ã–º –∑–∞–ø—Ä–æ—Å–æ–º
                await asyncio.sleep(CONFIG['DELAY_BETWEEN_REQUESTS'])
                
                # –í—Ç–æ—Ä–æ–π –∑–∞–ø—Ä–æ—Å
                second_url = CONFIG['API_URLS']['second'].format(task_id=task_id)
                stock_data = await self.make_api_request(session, second_url, headers, context, chat_id)
                
                if not stock_data:
                    return
                
                # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –≤—ã–≤–æ–¥
                formatted_data = self.format_stock_data(stock_data)
                low_stock_data = self.format_stock_data(stock_data, highlight_low=True)
                
                # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                if formatted_data:
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text="üì¶ –û—Å—Ç–∞—Ç–∫–∏ –Ω–∞ —Å–∫–ª–∞–¥–∞—Ö:\n" + "\n".join(formatted_data)
                    )
                
                if low_stock_data:
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text="‚ö†Ô∏è –¢–û–í–ê–†–´ –ó–ê–ö–ê–ù–ß–ò–í–ê–Æ–¢–°–Ø! ‚ö†Ô∏è\n" + "\n".join(low_stock_data)
                    )
                
        except Exception as e:
            logger.critical(f"CRITICAL ERROR for chat {chat_id}: {str(e)}", exc_info=True)
            await context.bot.send_message(chat_id=chat_id, text=f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")

    async def make_api_request(self, session, url, headers, context, chat_id, max_retries=3, timeout=30):
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç API –∑–∞–ø—Ä–æ—Å —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
        for attempt in range(max_retries):
            try:
                async with session.get(url, headers=headers, timeout=timeout) as response:
                    if response.status != 200:
                        error_msg = f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {response.status}"
                        logger.critical(f"CRITICAL: {error_msg} –¥–ª—è URL: {url}")
                        await context.bot.send_message(
                            chat_id=chat_id,
                            text=f"‚ùå {error_msg}"
                        )
                        return None
                    return await response.json()
            except asyncio.TimeoutError:
                if attempt < max_retries - 1:
                    logger.warning(f"–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}/{max_retries}, –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞...")
                    await asyncio.sleep(5)  # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
                    continue
                error_msg = "–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞"
                logger.critical(f"CRITICAL: {error_msg} –¥–ª—è URL: {url}")
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚ùå {error_msg}"
                )
                return None
            except Exception as e:
                error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞: {str(e)}"
                logger.critical(f"CRITICAL: {error_msg} –¥–ª—è URL: {url}", exc_info=True)
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚ùå {error_msg}"
                )
                return None

    async def start_periodic_checks(self, chat_id: int):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —á–∞—Ç–∞"""
        try:
            if chat_id in self.active_jobs:
                self.active_jobs[chat_id].schedule_removal()
            
            job = self.application.job_queue.run_repeating(
                callback=self.fetch_wb_data,
                interval=timedelta(minutes=CONFIG['CHECK_INTERVAL']),
                first=0,
                chat_id=chat_id,
                name=str(chat_id)
            )
            self.active_jobs[chat_id] = job
            return job
        except Exception as e:
            logger.critical(f"CRITICAL: –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫: {str(e)}", exc_info=True)
            raise

    async def stop_periodic_checks(self, chat_id: int):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —á–∞—Ç–∞"""
        try:
            if chat_id in self.active_jobs:
                self.active_jobs[chat_id].schedule_removal()
                del self.active_jobs[chat_id]
                return True
            return False
        except Exception as e:
            logger.critical(f"CRITICAL: –û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫: {str(e)}", exc_info=True)
            raise

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        await update.message.reply_text(
            "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ—Å—Ç–∞—Ç–∫–æ–≤ Wildberries.\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π /get_stock –¥–ª—è —Ä–∞–∑–æ–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏\n"
            "/auto_check –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫\n"
            "/stop_check –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫"
        )
    except Exception as e:
        logger.critical(f"CRITICAL: –û—à–∏–±–∫–∞ –≤ start: {str(e)}", exc_info=True)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Å—Ç–∞—Ç–∫–æ–≤
async def get_stock(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        bot = context.bot_data.get('wb_bot')
        if not bot:
            raise Exception("–ë–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        
        # –°–æ–∑–¥–∞–µ–º –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —Ä–∞–∑–æ–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
        class FakeContext:
            def __init__(self, chat_id, bot):
                self._chat_id = chat_id
                self.bot = bot
        fake_context = FakeContext(update.effective_chat.id, context.bot)
        await bot.fetch_wb_data(fake_context)
    except Exception as e:
        logger.critical(f"CRITICAL: –û—à–∏–±–∫–∞ –≤ get_stock: {str(e)}", exc_info=True)
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Å—Ç–∞—Ç–∫–æ–≤")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
async def auto_check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        bot = context.bot_data.get('wb_bot')
        if not bot:
            raise Exception("–ë–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        
        chat_id = update.effective_chat.id
        await bot.start_periodic_checks(chat_id)
        await update.message.reply_text(
            f"‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–ø—É—â–µ–Ω—ã (–∫–∞–∂–¥—ã–µ {CONFIG['CHECK_INTERVAL']} –º–∏–Ω—É—Ç –≤ —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è)"
        )
    except Exception as e:
        logger.critical(f"CRITICAL: –û—à–∏–±–∫–∞ –≤ auto_check: {str(e)}", exc_info=True)
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
async def stop_check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        bot = context.bot_data.get('wb_bot')
        if not bot:
            raise Exception("–ë–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        
        chat_id = update.effective_chat.id
        if await bot.stop_periodic_checks(chat_id):
            await update.message.reply_text("üõë –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
        else:
            await update.message.reply_text("‚ÑπÔ∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫")
    except Exception as e:
        logger.critical(f"CRITICAL: –û—à–∏–±–∫–∞ –≤ stop_check: {str(e)}", exc_info=True)
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫")

# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
def main():
    try:
        application = Application.builder().token(CONFIG['TG_API_KEY']).build()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
        application.bot_data['wb_bot'] = WBStockBot(application)
        
        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("get_stock", get_stock))
        application.add_handler(CommandHandler("auto_check", auto_check))
        application.add_handler(CommandHandler("stop_check", stop_check))
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        def signal_handler(signum, frame):
            print("\n–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            # –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
            asyncio.create_task(application.stop())
        
        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
        
        print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
        application.run_polling()
       

    except Exception as e:
        logger.critical(f"CRITICAL: –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {str(e)}", exc_info=True)
        raise

if __name__ == '__main__':
    main()